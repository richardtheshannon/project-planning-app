Timezone Issue Resolution Documentation
Issue Summary
Feature requests with due dates were displaying one day behind in the Activity Calendar and not appearing in the Today/Tomorrow cards on the Operations Dashboard, despite showing the correct date in the Feature Requests interface.
Root Cause Analysis
The Problem
JavaScript's Date object and HTML date inputs handle timezones differently:

HTML date inputs (<input type="date">) create dates at midnight in the browser's local timezone
PostgreSQL/Prisma stores dates as UTC timestamps
JavaScript Date comparisons use the local timezone by default
Date display methods can interpret dates differently based on timezone

Example Scenario

User in PST (UTC-8) selects "December 20, 2024" in date input
Browser creates: 2024-12-20T00:00:00-08:00 (midnight PST)
When saved to database: Converts to 2024-12-20T08:00:00Z (8 AM UTC)
When retrieved and compared locally: May interpret as December 19th depending on timezone handling

The Solution
1. Consistent UTC Date Display
Pattern: Always display dates using UTC timezone to match how they're stored.
typescript// ❌ INCORRECT - Uses local timezone
new Date(dateValue).toLocaleDateString()

// ✅ CORRECT - Forces UTC timezone
new Date(dateValue).toLocaleDateString('en-US', { timeZone: 'UTC' })
2. UTC Date Comparison for Filtering
Pattern: Compare dates using UTC date strings instead of Date object methods.
typescript// ❌ INCORRECT - Compares in local timezone
import { isSameDay } from 'date-fns';
const itemsForDay = allItems.filter(item => isSameDay(item.dueDate, day));

// ✅ CORRECT - Custom UTC comparison
const isSameDayUTC = (date1: Date, date2: Date): boolean => {
  const d1 = new Date(date1).toLocaleDateString('en-US', { timeZone: 'UTC' });
  const d2 = new Date(date2).toLocaleDateString('en-US', { timeZone: 'UTC' });
  return d1 === d2;
};
const itemsForDay = allItems.filter(item => isSameDayUTC(item.dueDate, day));
3. API Date Handling
Pattern: Save dates directly from HTML input without timezone manipulation.
typescript// ✅ CORRECT - Simple and consistent
const dueDateValue = dueDate ? new Date(dueDate) : null;

// Note: We tried noon UTC (T12:00:00Z) but it wasn't necessary
// The key is consistent handling across the application
Implementation Files & Changes
1. /src/app/FeatureRequests.tsx
typescript// Display dates with UTC timezone
<TableCell>
  {request.dueDate 
    ? new Date(request.dueDate).toLocaleDateString('en-US', { timeZone: 'UTC' }) 
    : 'N/A'}
</TableCell>
2. /src/app/dashboard/operations/page.tsx
typescript// Filter using UTC date comparison
const todayDateStr = today.toLocaleDateString('en-US', { timeZone: 'UTC' });
const tomorrowDateStr = tomorrow.toLocaleDateString('en-US', { timeZone: 'UTC' });

const todayItems = allItems.filter(item => {
  const itemDateStr = new Date(item.dueDate).toLocaleDateString('en-US', { timeZone: 'UTC' });
  return itemDateStr === todayDateStr;
});
3. /src/app/dashboard/operations/components/InteractiveCalendar.tsx
typescript// Add UTC comparison helper
const isSameDayUTC = (date1: Date, date2: Date): boolean => {
  const d1 = new Date(date1).toLocaleDateString('en-US', { timeZone: 'UTC' });
  const d2 = new Date(date2).toLocaleDateString('en-US', { timeZone: 'UTC' });
  return d1 === d2;
};

// Use it for filtering
const itemsForDay = allItems.filter(item => isSameDayUTC(item.dueDate, day));
4. /src/app/api/feature-requests/route.ts & /src/app/api/feature-requests/[id]/route.ts
typescript// Save dates without manipulation
const dueDateValue = dueDate ? new Date(dueDate) : null;

await prisma.featureRequest.create({
  data: {
    // ... other fields
    dueDate: dueDateValue,
  },
});
Best Practices for Future Development
1. Always Use UTC for Display
When displaying any date from the database:
typescriptnew Date(dateValue).toLocaleDateString('en-US', { timeZone: 'UTC' })
2. Create Reusable Utilities
Consider creating a utilities file:
typescript// utils/dateHelpers.ts
export const formatDateUTC = (date: Date | string | null): string => {
  if (!date) return 'Not set';
  return new Date(date).toLocaleDateString('en-US', { timeZone: 'UTC' });
};

export const isSameDayUTC = (date1: Date, date2: Date): boolean => {
  const d1 = new Date(date1).toLocaleDateString('en-US', { timeZone: 'UTC' });
  const d2 = new Date(date2).toLocaleDateString('en-US', { timeZone: 'UTC' });
  return d1 === d2;
};

export const getUTCDateString = (date: Date): string => {
  return date.toLocaleDateString('en-US', { timeZone: 'UTC' });
};
3. Consistent Pattern Across Features
This same pattern is already successfully used in:

Timeline Events (/api/timeline-events/)
Tasks (Project detail page)
Project start/end dates

4. Testing Considerations
When testing date features:

Test with different system timezones
Verify dates near timezone boundaries (11 PM, midnight, 1 AM)
Ensure consistency between list views, detail views, and calendars

Why This Solution Works

Database Storage: Dates are stored as UTC timestamps in PostgreSQL
HTML Input: Date inputs provide YYYY-MM-DD format without timezone info
Display Consistency: Using { timeZone: 'UTC' } ensures the date displays as stored
Comparison Accuracy: Comparing UTC date strings eliminates timezone shift issues

Alternative Approaches (Not Recommended)
We explored but rejected these approaches:

Setting noon UTC (T12:00:00Z): Adds complexity without solving the core issue
Timezone offset calculations: Error-prone and complex
Using date-fns-tz library: Unnecessary when simple UTC comparison works

Conclusion
The key insight is that date-only values should be treated as timezone-agnostic. By consistently using UTC for display and comparison, we ensure that "December 20th" remains "December 20th" regardless of the user's timezone. This approach is simple, reliable, and already proven in other parts of the application.